1. Objective

This document specifies how BSC Nexus can reduce Maximal Extractable Value (MEV) exposure for users by preventing public mempool leakage and by routing transactions through private relays when available. It also defines QA tests to verify that anti-MEV routing is active.

Scope:

Transaction privacy for eth_sendRawTransaction

Optional randomized routing and broadcast delay

Relay failover and observability

Test coverage using the existing QA framework

Out of scope (for this document):

On-chain MEV-resistant contract design

Miner/validator side modifications

2. Background

MEV on BSC typically occurs when transactions broadcast to the public mempool are observed and exploited by searchers, resulting in front-running, sandwiching, or back-running. Standard public RPC nodes forward transactions to the public mempool immediately. BSC Nexus, acting as an application-layer RPC proxy, can mitigate exposure by routing signed transactions through private relays or sealed submission channels, avoiding public mempool visibility prior to inclusion.

3. Architecture

High-level flow:

User Wallet (signed raw tx)
        |
        v
BSC Nexus RPC Proxy (/rpc)
  - API Key/Auth (optional)
  - Anti-MEV Filter (enabled by env/config)
  - Broadcast Strategy:
      * Private Relay (primary)
      * Public RPC (fallback)
  - Telemetry + Logs
        |
        v
Upstream Endpoint(s)
  - Private Relay (if configured)
  - Public RPC(s) for fallback


Key components:

Proxy Layer: intercepts eth_sendRawTransaction, applies anti-MEV policy, forwards to private relay.

Routing Policy: primary → private relay; fallback → public RPC provider(s).

Observability: measure response codes/latency; log relay usage; expose counters for QA.

Configuration: controlled via environment variables and per-request flags.

4. Configuration

Extend .env:

# Anti-MEV feature flags
ANTI_MEV_ENABLED=true

# Primary private relay for sealed tx submission (example URL)
PRIVATE_RELAY_URL=https://your-private-relay.example.com

# Optional: comma-separated list of public RPC fallbacks
PUBLIC_RPC_FALLBACKS=https://bsc-dataseed.binance.org,https://rpc.ankr.com/bsc

# Broadcast behavior
ANTI_MEV_RANDOM_DELAY_MS_MIN=20
ANTI_MEV_RANDOM_DELAY_MS_MAX=120
ANTI_MEV_HARD_FAIL_ON_RELAY_ERROR=false


Notes:

ANTI_MEV_ENABLED=false disables all anti-MEV logic; proxy behaves as a normal forwarder.

If ANTI_MEV_HARD_FAIL_ON_RELAY_ERROR=true, the proxy returns an error if the private relay fails (no fallback to public).

Random delay is optional, intended to slightly decorrelate submission timing.

5. Proxy Integration

Update your /rpc handler to route eth_sendRawTransaction through the anti-MEV path.

Example (TypeScript-style pseudocode inside your server; adapt to your codebase):

import axios from "axios";

const relayUrl = process.env.PRIVATE_RELAY_URL || "";
const antiMEV = (process.env.ANTI_MEV_ENABLED || "false").toLowerCase() === "true";
const hardFail = (process.env.ANTI_MEV_HARD_FAIL_ON_RELAY_ERROR || "false").toLowerCase() === "true";

function pickPublicFallback(): string | null {
  const list = (process.env.PUBLIC_RPC_FALLBACKS || "").split(",").map(s => s.trim()).filter(Boolean);
  if (list.length === 0) return null;
  return list[Math.floor(Math.random() * list.length)];
}

function randomDelayMs(): number {
  const min = parseInt(process.env.ANTI_MEV_RANDOM_DELAY_MS_MIN || "0", 10);
  const max = parseInt(process.env.ANTI_MEV_RANDOM_DELAY_MS_MAX || "0", 10);
  if (max <= min) return 0;
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

async function forwardJsonRpc(url: string, body: any, timeout = 15000) {
  return axios.post(url, body, { timeout, headers: { "Content-Type": "application/json" } });
}

// Inside your Express route:
app.post("/rpc", async (req, res) => {
  const body = req.body;

  // Only apply anti-MEV to raw transaction submission
  const isSendRaw = body?.method === "eth_sendRawTransaction";

  // Optional per-request override: allow clients to disable anti-MEV
  const disableAntiMev = Boolean(req.headers["x-disable-anti-mev"]) || body?.params?.[1]?.disableAntiMev === true;

  try {
    if (antiMEV && isSendRaw && !disableAntiMev && relayUrl) {
      const delay = randomDelayMs();
      if (delay > 0) await new Promise(r => setTimeout(r, delay));

      // Primary: private relay
      try {
        const relayResp = await forwardJsonRpc(relayUrl, body);
        return res.status(200).json(relayResp.data);
      } catch (relayErr: any) {
        // Relay failure
        if (hardFail) {
          return res.status(502).json({
            jsonrpc: "2.0",
            id: body?.id ?? 1,
            error: { code: -32001, message: "Private relay unavailable" }
          });
        }
        // Fallback to public RPC
        const fallback = pickPublicFallback();
        if (!fallback) {
          return res.status(502).json({
            jsonrpc: "2.0",
            id: body?.id ?? 1,
            error: { code: -32002, message: "No fallback RPC configured" }
          });
        }
        const fbResp = await forwardJsonRpc(fallback, body);
        return res.status(200).json(fbResp.data);
      }
    }

    // Default path for non-transaction or anti-MEV disabled cases:
    // Forward to primary public RPC (or your existing routing)
    const primary = process.env.BSC_RPC_URL || pickPublicFallback();
    if (!primary) {
      return res.status(500).json({
        jsonrpc: "2.0",
        id: body?.id ?? 1,
        error: { code: -32003, message: "No upstream RPC configured" }
      });
    }
    const resp = await forwardJsonRpc(primary, body);
    return res.status(200).json(resp.data);

  } catch (err: any) {
    return res.status(500).json({
      jsonrpc: "2.0",
      id: body?.id ?? 1,
      error: { code: -32603, message: "Internal error", data: err?.message || "unknown" }
    });
  }
});


Security notes:

Do not modify or inspect private keys. The endpoint accepts only signed transactions (eth_sendRawTransaction).

Do not log raw transaction data in production.

Consider adding API key authentication to control access and rate limits.

6. QA Tests

Add tests/mev.ts to verify the routing behavior (no relay credentials required; this validates control-plane logic).

import axios from "axios";
import { TestResult } from "../types.js";

export async function testAntiMEV(config): Promise<TestResult[]> {
  const results: TestResult[] = [];
  const start = Date.now();

  // Dummy raw tx payload (non-broadcastable; for control-path testing only)
  const raw = "0x01deadbeef"; // deliberately invalid so upstream will reject; we only assert routing logic.

  try {
    // Attempt with anti-MEV enabled at server level (assumes feature ON)
    const resp = await axios.post(`${config.serverUrl}/rpc`, {
      jsonrpc: "2.0",
      id: 1,
      method: "eth_sendRawTransaction",
      params: [raw]
    }, { timeout: 8000 });

    // We don't require a successful chain acceptance; we only check that the server returned a JSON-RPC shaped response.
    const valid = resp?.data && typeof resp.data === "object" && ("result" in resp.data || "error" in resp.data);

    results.push({
      name: "Anti-MEV route: JSON-RPC envelope",
      passed: Boolean(valid),
      duration: Date.now() - start,
      details: valid ? "Received JSON-RPC structured response" : `Unexpected: ${JSON.stringify(resp?.data).slice(0, 200)}`
    });

  } catch (err: any) {
    // If the server is enforcing hard fail on relay error, we still want a JSON-RPC error envelope
    const msg = err?.response?.data ? JSON.stringify(err.response.data) : err.message;
    const jsonrpcish = (() => {
      try {
        const d = err?.response?.data;
        return d && typeof d === "object" && ("result" in d || "error" in d);
      } catch { return false; }
    })();

    results.push({
      name: "Anti-MEV route: error envelope",
      passed: jsonrpcish,
      duration: Date.now() - start,
      details: msg,
      suggestion: jsonrpcish ? undefined : "Ensure /rpc returns JSON-RPC shaped errors on relay/fallback failure."
    });
  }

  return results;
}


Register in test-runner.ts:

import { testAntiMEV } from "./tests/mev.js";

const testSuites = [
  { name: "Health Checks", fn: () => testHealth(config) },
  { name: "RPC Proxy", fn: () => testRPC(config) },
  { name: "Token RPC", fn: () => testTokens(config) },
  { name: "Anti-MEV", fn: () => testAntiMEV(config) },
];


This test confirms:

/rpc returns a JSON-RPC shaped response for eth_sendRawTransaction.

The server does not leak raw errors or HTML, even on relay failure.

Control path is active (without needing a real private relay).

7. Relay Fallback and Error Policy

Recommended defaults:

ANTI_MEV_ENABLED=true

ANTI_MEV_HARD_FAIL_ON_RELAY_ERROR=false

At least one PUBLIC_RPC_FALLBACKS endpoint configured

Behavior:

Try private relay first.

If relay fails and HARD_FAIL=false, forward to a random fallback public RPC.

Always return JSON-RPC shaped responses.

8. Observability

Add minimal logs and counters:

Count relay submissions vs. fallbacks.

Record latency per upstream endpoint.

Expose a simple /metrics JSON (or Prometheus-style) for QA:

relay_submissions_total

relay_failures_total

fallback_submissions_total

rpc_latency_ms{upstream="..."}

This allows future dashboards and automated alerts.

9. Security Considerations

Never accept unsigned transactions on behalf of a user. The proxy must handle only already-signed payloads.

Do not store raw transactions. Log minimal metadata (hash, timestamps) if required.

Add rate limits and optional API keys to mitigate abuse.

If implementing random delays, keep bounds low to avoid user-visible latency spikes.

10. Rollout Plan

Implement environment-flagged routing in /rpc.

Add tests/mev.ts and include in the runner.

Validate locally and in CI (JSON-RPC envelopes only).

Integrate with a real private relay when available.

Add metrics and minimal dashboard.

Document a client flag (e.g., x-disable-anti-mev) to allow opt-out.

11. Future Work

Relay provider adapters and health scoring.

Transaction bundle submission where supported.

Smart routing based on per-endpoint latency and error rates.

On-chain inclusion monitoring and MEV incident reporting.

Paid “Anti-MEV RPC” tier with stricter policies and SLAs.

Maintainer
Gorkhmaz Beydullayev
Lyon, France – 2025

Repository: https://github.com/grkhmz23/BSC-Nexus
